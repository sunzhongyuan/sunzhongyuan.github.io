{"meta":{"title":"各种学习笔记","subtitle":"O ever youthful,O ever weeping.","description":"O ever youthful,O ever weeping.","author":"zyzy","url":"http://sunzhongyuan.net"},"pages":[{"title":"categories","date":"2018-06-24T13:21:31.000Z","updated":"2018-08-13T12:44:07.531Z","comments":false,"path":"categories/index.html","permalink":"http://sunzhongyuan.net/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-24T15:55:39.000Z","updated":"2018-08-13T12:43:55.424Z","comments":false,"path":"tags/index.html","permalink":"http://sunzhongyuan.net/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java基础回顾5","slug":"javase5","date":"2018-12-13T13:13:27.000Z","updated":"2019-01-02T09:46:38.958Z","comments":true,"path":"2018/12/13/javase5/","link":"","permalink":"http://sunzhongyuan.net/2018/12/13/javase5/","excerpt":"集合类 可变容器类与数组相比集合主要针对数据长度可变的情况 集合与数组的区别： 数组是固定长度，集合的长度是可变的 数组只能存放基本数据类型，集合只能放引用数据类型 集合中对于基本数据类型会转换为引用数据类型再存储","text":"集合类 可变容器类与数组相比集合主要针对数据长度可变的情况 集合与数组的区别： 数组是固定长度，集合的长度是可变的 数组只能存放基本数据类型，集合只能放引用数据类型 集合中对于基本数据类型会转换为引用数据类型再存储 集合框架 Collection-接口 List-接口：有序可重复，每个元素都有对应索引，可以通过索引访问指定位置的元素 ArrayList-实现类：除了实现了List接口的方法，还额外增加了几个方法，元素允许有null LinkedList-实现类：链表类数据结构，添加删除效率高，查询效率不如ArrayList Set-接口：存放无序不可重复的元素 HashSet-实现类：通过一个Hash函数计算产生的HashCode决定该集合存放在哪；添加元素时先比较hashCode，再比较equals方法来判断添加的是否是重复元素 TreeSet-实现类：有序集合，默认将元素按照升序排序，因为实现了Comparable接口 Map-接口： 主要存储键值对key-value键值对，key不能重复 HashMap HashTable ArrayList与LinkedList的不同 ArrayList每个元素都有索引，所以查询速度快 LinkedList是链表结构，将对象存放在独立的空间中，每个空间保存了下一个链接的索引，所以查询速度慢 ArrayList 初始化： 指定数据类型：ArrayList&lt;E&gt; arrayList=new ArrayList&lt;E&gt;();可以指定ArrayList存放的数据类型，可以是任意数据类型，包括自定义类 没有指定类型：ArrayList arrayList=new ArrayList();没有指定数据类型，随便存，导致get出来不确定是什么数据类型，所以不常用 主要方法： boolean add(E e) 将指定的元素追加到此列表的末尾。 void add(int index, E element) 在此列表中的指定位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c) 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 boolean contains(Object o) 如果此列表包含指定的元素，则返回 true 。 E get(int index) 返回此列表中指定位置的元素。 E remove(int index) 删除该列表中指定位置的元素。 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素 Object[] toArray() 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 LinkedList 初始化：同ArrayList 主要方法： void addFirst(E e) 在该列表开头插入指定的元素。 void addLast(E e) 将指定的元素追加到此列表的末尾 E peekFirst() 检索但不删除此列表的第一个元素，如果此列表为空，则返回 null 。 peekLast() 检索但不删除此列表的最后一个元素，如果此列表为空，则返回 null 。 pop() 从此列表表示的堆栈中弹出一个元素。 List集合的遍历12345678910111213141516171819202122ArrayList&lt;Integer&gt; alist = new ArrayList&lt;Integer&gt;();for(int i = 0; i&lt;3; i++)&#123; alist.add(i);&#125;// 方法一：List.size()for(int i = 0; i&lt;alist.size(); i++)&#123; System.out.println(alist.get(i));&#125;// 方法二：迭代器IteratorIterator&lt;Integer&gt; iterator = alist.iterator();while(iterator.hasNext())&#123; System.out.println(iterator.next());&#125;// 方法三：增强for循环for(Integer integer:alist)&#123; System.out.println(integer);&#125;// 方法四：jdk1.8新特性，foreachalist.foreach(integer-&gt;&#123;System.out.println(integer);&#125;); HashSet 元素无序不可重复 HashSet&lt;E&gt; hashset = new HashSet&lt;E&gt;(); 主要方法： boolean add(E e) 将指定的元素添加到此集合（如果尚未存在）。 boolean contains(Object o) 如果此集合包含指定的元素，则返回 true 根据对象的equals方法判断是否是重复元素，所以存放自定义类型需要重写hashCode方法和equals方法12345678910111213141516171819202122232425262728293031public class Student &#123; private String id; private String name; private char sex; public Student(String id,String name,char sex) &#123; this.id=id; this.name=name; this.sex=sex; &#125; //重写 hashcode public int hashCode() &#123; return id.hashCode(); &#125; //重写 equals public boolean equals(Object obj) &#123; if(this == obj) return true; if(obj instanceof Student) &#123; //向下转型 Student stu=(Student) obj; if(stu.name==this.name &amp;&amp; stu.id==this.id&amp;&amp; stu.sex==this.sex) return true; &#125; return false; &#125; //重写 toString public String toString() &#123; return \"[\"+this.id+\",\"+this.name+\",\"+this.sex+\"]\"; &#125; ....&#125; TreeSet有序集合，默认将元素按照升序排序，因为实现了Comparable接口 TreeSet&lt;E&gt; treeset = new TreeSet&lt;E&gt;(); 自定义数据类型需要实现Comparable 12345678910111213141516171819202122232425262728293031323334353637public class Person implements Comparator&lt;Person&gt;&#123; private String name; private int age; //无参构造函数 public Person() &#123; &#125; public Person(String name,int age) &#123; this.name=name; this.age=age; &#125; /* * 根据年龄大小进行排序 * * */ @Override public int compare(Person p1, Person p2) &#123; // TODO Auto-generated method stub if(p1.age&gt;p2.age) &#123; //大于的时候 return 1; &#125;else if(p1.age&lt;p2.age) &#123; //小于的时候 return -1; &#125;else &#123; //相等的时候 return 0; &#125; &#125; //重写 public String toString() &#123; return \"[\"+this.name+\",\"+this.age+\"]\"; &#125; ....&#125; 1234567891011121314151617public class TreeSetTest02 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // Step 1 初始化 treeset 并指定新的比较器 TreeSet&lt;Person&gt; ts=new TreeSet&lt;Person&gt;(new Person()); //step 2 person 初始化 Person p1= new Person(\"张三\",20); Person p2= new Person(\"李四\",22); Person p3= new Person(\"王五 \",18); //step 3 增加对象 ts.add(p1); ts.add(p2); ts.add(p3); //自然顺序进行排序 System.out.println(ts); &#125;&#125; HashMappublic class HashMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable允许null的值和null键。HashMap&lt;key,value&gt; hashMap=new HashMap&lt;key,value&gt; (); 常用方法： put(K key, V value) 将指定的值与此映射中的指定键相关联 get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图。 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。 boolean containsValue(Object value) 如果此地图将一个或多个键映射到指定值，则返回 true 。 循环HashSet：123456789101112131415161718192021222324252627282930//step 1 初始化 HashMapHashMap&lt;String,Student&gt; hashMap=new HashMap&lt;String,Student&gt; ();//step2 初始化学生对象Student stu1=new Student(\"20180001\",\"张三\",'男');Student stu2=new Student(\"20180002\",\"李四\",'男');Student stu3=new Student(\"20180003\",\"王五\",'男');//step 3 put key 可以自己定义 也可以使用既有的 最好有规范 便于计算。 wordCount//不能重复hashMap.put(\"00000011\", stu1);hashMap.put(stu2.getId(),stu2);hashMap.put(\"00000012\",stu3);//允许 null值hashMap.put(null,null);//循环hashMap// 4-1 keyset 通过 Map当中的 keyset方法 获得 key的 set集合Set&lt;String&gt; keyset=hashMap.keySet();Iterator&lt;String&gt; it=keyset.iterator(); while(it.hasNext()) &#123; String key=it.next(); System.out.println(key+\":\"+hashMap.get(key));&#125;//4-2 entrySet Collettion---推荐使用Iterator it2=hashMap.entrySet().iterator();while(it2.hasNext()) &#123; //获得entry entry 是一个接口 类似 instanceof 向下转型 Map.Entry&lt;String, Student&gt; entry=(Map.Entry&lt;String, Student&gt;)it2.next(); System.out.println(entry.getKey()+\":\"+entry.getValue());&#125; HashTable不接受Null，为了成功的在hashtable中存储和获取对象，用作键的对象必须实现 hashcode和equals方法。123456789101112131415161718192021//Step 1 初始化 hash表Hashtable&lt;String,Student&gt; hashTable=new Hashtable&lt;String,Student&gt;();//step2 初始化学生对象Student stu1=new Student(\"20180001\",\"张三\",'男');Student stu2=new Student(\"20180002\",\"李四\",'男');Student stu3=new Student(\"20180003\",\"王五\",'男');//step 3 put key 可以自己定义 也可以使用既有的 最好有规范 便于计算。 wordCount//不能重复hashTable.put(\"00000011\", stu1);hashTable.put(stu2.getId(),stu2);hashTable.put(\"00000012\",stu3);//不允许 null值// hashTable.put(null,null);//hashTable 特有的循环 Enumeration&lt;V&gt; elements() 返回此散列表中值的枚举。Enumeration&lt;String&gt; enu=hashTable.keys();while(enu.hasMoreElements()/*类比 hasNext*/) &#123; String key=enu.nextElement(); System.out.println(key+\":\"+hashTable.get(key));&#125;","categories":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"http://sunzhongyuan.net/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://sunzhongyuan.net/tags/java基础/"}]},{"title":"java基础回顾4","slug":"javase4","date":"2018-12-04T14:02:37.000Z","updated":"2018-12-12T15:47:24.841Z","comments":true,"path":"2018/12/04/javase4/","link":"","permalink":"http://sunzhongyuan.net/2018/12/04/javase4/","excerpt":"Java APIjava.lang –核心包，不用引用，直接使用","text":"Java APIjava.lang –核心包，不用引用，直接使用 Math类Math类为java提供支持数值运算的类 Math提供的基本方法 static double abs(double a) 返回值为 double绝对值。 static double acos(double a) 返回值的反余弦值; 返回的角度在0.0到pi的范围内。 static double atan(double a) 向上取整：static double ceil(double a) 返回大于或等于参数的最小（最接近负无穷大） double值，等于一个数学整数。 向下取整：static double floor(double a) 返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 四舍五入：static long round(double a) 返回参数中最接近的 long ，其中 long四舍五入为。 static double log(double a) 返回的自然对数（以 e为底） double值。 static double log10(double a) 返回一个 double的基数10对数值 static int max(int a, int b) 返回两个 int值中的较大值。 static double random() 返回值为 double值为正号，大于等于 0.0 ，小于 1.0 。 public static double sqrt(double a) String类特殊的引用数据类型 常用方法 char charAt(int index) 返回 char指定索引处的值 boolean contains(CharSequence s) 当且仅当此字符串包含指定的char值序列时才返回true。 boolean equals(Object anObject) 将此字符串与指定对象进行比较。 indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 length() 返回此字符串的长度。—循环的中止条件 boolean matches(String regex) 告诉这个字符串是否匹配给定的 regular expression 。 String replace(char oldChar, char newChar) 返回从替换所有出现的导致一个字符串 oldChar在此字符串 newChar 。 String[] split(String regex) 将此字符串分割为给定的 regular expression的匹配。 String substring(int beginIndex) 返回一个字符串，该字符串是此字符串的子字符串。 String toLowerCase() 将所有在此字符 String使用默认语言环境的规则，以小写。 String toUpperCase() 将所有在此字符 String使用默认语言环境的规则大写。 String trim() 返回一个字符串，其值为此字符串，并删除任何前导和尾随空格。 String == 与equals的区别 如果声明String 是通过 String str=”” ,我们可以用 == equals 声明String 通过 new String(“”),不可以用 ==（调用 Object的equals方法） 只能用 equals 练习：字符串运算-大写字母 小写字母 数字出现的次数 1234567891011121314151617181920public static void getCount(String s) &#123; //记录大小写字母 数字出现次数 int upper=0; int lower=0; int digit=0; //for 循环遍历--对字符串中的每一个字符进行比对 for(int i=0;i&lt;s.length();i++) &#123; //定义一个char 用来存储我们每个字符串中字符 char c=s.charAt(i); //通过 AscII 来判断 数字 48 大写字母 65 小写字母 97 if(c&gt;='0'&amp;&amp;c&lt;='9') &#123; digit++; &#125;else if(c&gt;='A'&amp;&amp;c&lt;='Z') &#123; upper++; &#125;else if(c&gt;='a'&amp;&amp;c&lt;='z') &#123; lower++; &#125; &#125;&#125; split方法-字符串的运算 split() 方法用于把一个字符串分割成字符串数组。 例子： 1234567891011121314String str = \"1,2,3,4,5\";String[] s = str.split(\",\");// s = &#123;\"1\",\"2\",\"3\",\"4\",\"5\"&#125;// s.length = 5String str = \"1,2,3,4,5,\";String[] s = str.split(\",\");// s = &#123;\"1\",\"2\",\"3\",\"4\",\"5\"&#125;// s.length = 5String str = \",1,2,3,4,5\";String[] s = str.split(\",\");// s = &#123;\"\",\"1\",\"2\",\"3\",\"4\",\"5\"&#125;// s.length = 6 如果用“.”作为分隔的话,必须是如下写法,String.split(“\\.”),这样才能正确的分隔开,不能用String.split(“.”); 如果用“|”作为分隔的话,必须是如下写法,String.split(“\\|”),这样才能正确的分隔开,不能用String.split(“|”); “.”和“|”都是转义字符,必须得加”\\“; 如果在一个字符串中有多个分隔符,可以用“|”作为连字符,比如,“acount=? and uu =? or n=?”,把三个都分隔出来,可以用String.split(“and|or”); 应用：可以用来统计单词个数 正则表达式 \\d：0-9的数字 \\D：非0-9的数字 \\w：数字字母下划线[a-zA-Z0-9_] X?：X出现一次或0次 X*：X出现多次或0次 X+：X出现一次或多次 X{n}：X出现n次 X{n,m}：n&lt;=X&lt;=m ^：以什么什么开头 $：以什么什么结尾 例子： QQ号码：[1-9]\\d{4,14} 手机号：[1][3-9]\\\\d{9} 邮箱：[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\\\.\\\\w{2,3})+ StringBuffer类 对String的一个扩展 可以任意调节数据字符串的长度和内容1234567891011// 构造一个没有字符的字符串缓冲区，初始容量为16个字符StringBuffer sbuffer = new StringBuffer();sbuffer.append(\"A\");sbuffer.append(\"B\");String s = \"123456789\";s+=\"CD\";sbuffer.append(s);System.out.println(sbuffer); // AB123456789CDsbuffer.insert(5, \"XXX\");System.out.println(sbuffer); // AB123XXX456789CDString str = sbuffer.toString(); Calendar日期类 抽象类，不能实例化，通过抽象类自带getInstance方法获得对象 获取当前时间：Calendar rightNow = Calendar.getInstance(); 常用方法： rightNow.get(Calendar.YEAR)：输出年 rightNow.get(Calendar.MONTH)+1：输出月，月份从0开始 rightNow.get(Calendar.DAY_OF_MONTH)：输出当月第几天 rightNow.set(2018, 11, 5)：设置日期为2018-12-5，注意月份从0开始 rightNow.add(Calendar.MONTH-12)：月份减10个月，年份跟着变化 rightNow.roll(Calendar.MONTH, 5)：月份加5个月，但是年不变 DateFormat格式化日期类 抽象类，不能实例化，通过抽象类自带getDateInstance方法获得对象 DateFormat df = DateFormat.getDateInstance() 常用方法： String str = df.format(new Date())：将日期格式化为字符串，格式为YYYY-MM-DD Date date = df.parse(str)：将字符串转换为日期格式 SimpleDateFormat （DateFormat子类） 不是抽象类了，继承了DateFormat SimpleDateFormat smf = new SimpleDateFormat(String pattern) 怎么用： 1234567SimpleDateFormat smf = new SimpleDateFormat();smf.applyPattern(\"yyyy年MM月dd日\");// 小写的dd表示当前月的第几天，输出：2018年12月05日System.out.println(smf.format(Calendar.getInstance().getTime()));smf.applyPattern(\"yyyy年MM月DD日\");// 大写的DD表示当前年的第几天，输出：2018年12月339日System.out.println(smf.format(Calendar.getInstance().getTime()));","categories":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"http://sunzhongyuan.net/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://sunzhongyuan.net/tags/java基础/"}]},{"title":"java基础回顾3","slug":"javase3","date":"2018-11-29T11:28:42.000Z","updated":"2018-12-03T13:38:57.819Z","comments":true,"path":"2018/11/29/javase3/","link":"","permalink":"http://sunzhongyuan.net/2018/11/29/javase3/","excerpt":"static关键字 主要用来修饰类的成员（成员变量、方法） static修饰的成员在类加载的时候直接运行，优先级高 通过类直接访问，类名.成员 static是针对所有对象的属性值相同时才使用static修饰 静态方法不能使用非静态的变量 非静态方法可以使用静态变量和非静态变量","text":"static关键字 主要用来修饰类的成员（成员变量、方法） static修饰的成员在类加载的时候直接运行，优先级高 通过类直接访问，类名.成员 static是针对所有对象的属性值相同时才使用static修饰 静态方法不能使用非静态的变量 非静态方法可以使用静态变量和非静态变量 静态构造代码块12345class 类&#123; static&#123; 局部变量 &#125;&#125; 主要是为了方便变量的统一初始化，执行且只执行一次。 同样是类加载时执行且执行一次 同样静态构造代码块不能使用非静态变量 构造代码块12345class 类&#123; &#123; 局部变量 &#125;&#125; 对对象的变量统一初始化 实例化对象时执行 可以使用静态变量和非静态变量 代码块在方法里定义的是普通代码块 静态构造代码块、构造代码块、构造函数执行顺序 静态构造代码块类加载时执行且执行一次，优先级最高 在实例化对象时先执行构造代码块，再执行构造函数 继承 子类继承父类，关键字extends 父类：基类、超类 子类：派生类 子类可以访问父类中的非私有的属性和方法 子类不能继承父类的构造方法 父类可以被多个子类继承，而子类只能有一个直接父类 方法的重写 区分重载：在同一个类中，方法名一样，参数列表不同 重写：在继承中出现，子类重写父类的方法，方法名，返回值，参数列表都相同 super关键字 在子类的构造方法中直接通过super关键字调用父类的构造方法（写在第一行调用） 如果父类和子类中有同名的成员变量，在子类中使用super.成员可以访问父类的成员变量，this.成员访问当前子类的成员变量 如果子类重写了父类的方法，可以通过super调用父类的方法 与this关键字类似，this表示当前类，super表示父类 final关键字可以用来修饰类、方法、变量 final 类：不能被继承，因为不想被重写方法，增加属性，不想被人改变，如String类 final 方法：不能被子类重写 final 变量：赋值后就不能再改了 final与static static：静态变量，只保留一个副本，加载类时执行一次，实例化对象时不会执行 final：常量，表示变量赋值后不可变 Object类顶级父类，是任何类的父类，可以显示继承，也可以隐式继承可以重写的方法： toString：输出类默认调用toString方法 equals：默认对比两个对象的地址，可以重写为对比两个类的属性 抽象方法 一种特殊的方法：只有声明没有方法体 格式：abstract 返回值类型 func(); 存在的意义：父类不想或无法提供方法的方法体，供子类进行重写 不能被final修饰 不能被private修饰 不能被static修饰 抽象类 如果一个类中含有抽象方法，则该类必须被定义为抽象类，反过来，抽象类不一定含有抽象方法，不过没有抽象方法的抽象类没有意义。 格式：abstract class obj{} 无法被实例化，只能被继承，不能被final修饰 接口(interface) 抽象类的延伸：如果一个类中所有的方法都是抽象方法，则可以定义成接口。 一个子类只能有一个直接父类，想要多继承，必须使用接口，接口可以实现多个，逗号分隔，子类必须实现接口的所有抽象方法 实现接口关键字implement 不能有构造方法 声明格式：interface 接口名{} 接口中变量的格式：public static final 变量名;但是不建议在接口中声明变量 接口中方法必须是抽象方法，默认是public abstract 抽象类与接口的区别 抽象类可以实现接口，接口可以继承接口，但是不能实现接口 接口不可以实例化，抽象类不可以实例化，但是可以在子类实例化时自动创建抽象类的对象(子类构造方法通过super调用抽象类的构造方法) 接口可以多实现，但是抽象类只能单继承 抽象类主要针对公共的属性，进行抽象，对于延伸的附加行为定义为接口。 访问控制权限用来修饰类、方法、变量，控制访问权限 public：表示包内及包外的任何类都可以访问 protected：表示包内的任何类、包外继承了该类的子类才能访问，突出继承 default：表示保内的任何类，但是包外的任何类都不能访问 private：只有本类可以访问，包内、包外都不能访问。用于封装 多态多态分为编译时的多态（静态多态）和运行时多态（动态多态）多态为了应对一类事物的多种表现形态 静态多态原理是方法的重载，通过方法参数的不同，实现静态多态不需要继承 动态多态引用类型在不同情况下所表现的实际对象不同实现动态多态需要： 继承，子类继承父类 重写，子类必须对父类的某些方法进行重写定义，调用这些方法时，就会调用子类的方法 向上转型，父类引用指向子类对象 向上转型子类的对象转换为父类类型Animal animal = new Cat()子类单独定义的方法会丢失，能访问子类重写父类的方法如果需要访问子类单独定义的方法，则需要向下转型 向下转型必须以向上转型为前提Cat cat = (Cat) animal 多态的应用：12person.feed(new Dog(), new Bone());person.feed(new Cat(), new Fish()); 调用一个feed方法，实现对不用动物的喂食 feed方法如下：1234public void feed(Animal animal,Food food) &#123; animal.eat(); food.showName();&#125; 内部类在类中声明一个类，可以有多个 成员内部类 和成员变量同级 在内部类中不能存在static关键字 可以无限访问外部类的变量和方法（包括private修饰的） 相当于另外一种继承 内部类与外部类成员名相同时，可以用外部类名.this.成员名来访问外部类成员 外部类访问内部类需要实例化内部类对象进行访问 其他类访问成员内部类： 首先实例化外部类对象 然后实例化内部类对象外部类.内部类 类名 = 外部类.new 内部类() 也可以通过外部类的方法返回内部类对象 静态成员内部类 使用static修饰的内部类 类比静态成员变量，可以通过外部类直接调用构造方法进行实例化外部类.内部类() 可以访问外部类中所有静态成员（包含private修饰的） 局部内部类 局部范围内有效的内部类（如方法里定义的） 类比局部变量，不能有public protected private以及static修饰 可以无限制访问外部类的变量和方法（包括private修饰的） 匿名局部内部类 没有名字的局部内部类 必须要继承一个父类或实现一个接口 不能有静态成员 如何定义： 12345678new 父类构造方法或者接口名() &#123; // 匿名局部内部类 //重写父类的一个方法 修饰符 返回参数类型 方法名(参数列表)&#123; &#125; // 也可以声明自己的变量和方法，但是只在内部类有效&#125;; 匿名局部内部类继承了父类或实现了接口，不需要新写一个类去继承或实现接口，在实例化对象的时候用匿名类去重写方法 123456789101112131415161718192021public static void main(String[] args) &#123; // TODO Auto-generated method stub //方式1 通过新建一个类 实现接口 HPprinter hp=new HPprinter(); hp.print(); //方式2 通过 匿名内部类的方式 //接口没有构造函数 不能够实例化 //Printer printer=new Printer(); Printer printer=new Printer() &#123;// 匿名内部类 @Override public void print() &#123; // TODO Auto-generated method stub System.out.println(\"方式2通过匿名内部类：惠普打印机打印\"); &#125; &#125;; printer.print(); System.out.println(printer.getClass());&#125; 内部类总结 外部类也可以继承一个直接父类，而每个内部类都可以独立继承或实现一个接口，这样这个外部类就间接继承了多个类—–多继承的一种表现 通过内部类可以实现对外界的隐藏—–封装的一种表现 内部类可以无限制的使用外部类的成员（包括私有），不用生成外部类对象 匿名内部类可以简化代码编写，方便编写事件驱动的程序、线程程序","categories":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"http://sunzhongyuan.net/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://sunzhongyuan.net/tags/java基础/"}]},{"title":"java基础回顾2","slug":"javase2","date":"2018-11-27T12:59:46.000Z","updated":"2018-11-28T15:54:51.143Z","comments":true,"path":"2018/11/27/javase2/","link":"","permalink":"http://sunzhongyuan.net/2018/11/27/javase2/","excerpt":"面向对象面向对象是对现实世界理解和抽象的一种方法三大特征：封装、继承、多态","text":"面向对象面向对象是对现实世界理解和抽象的一种方法三大特征：封装、继承、多态 对象对象指一个具体的实例，包含属性和方法。 类具有相同属性和方法的一组对象的集合类可以有子类 类和对象的关系类实例化出具体的对象 类的创建java用来处理数据，数据类型包括下列几种，java提供了一些，我们也可以创建自己需要的数据类型 基本数据类型：四类八种 引用数据类型：String 数组 接口等 自定义的数据类型-用户自己创建的类 1class修饰的就是类，包含这一类事物都包含的属性和方法，就不举例子了 实例化对象用类实例化一个具体的对象，这个对象拥有这个类的属性和方法，对象可以给这些属性赋值；如果两个对象的属性赋值都相同，这两个对象也是相互独立的个体，互不影响。1234类名 对象名1 = new 类名();类名 对象名2 = new 类名();对象名1.name = \"对象1\";对象名2.name = \"对象2\"; 成员变量和局部变量 成员变量：定义在类里的属性；存储在堆中。 局部变量：在局部内定义，在局部内有效，如方法体里定义，for循环内定义的变量；存储在栈中，生命周期长于成员变量 如果在一个方法体内有一个局部变量名和成员变量名重复，在方法体内调用这个变量时是局部变量的值 堆Heap：临时的，由创建对象时所开辟的一块空间，对象销毁后，系统回收栈：是方法生成的时候，压栈生成，整个程序结束后才销毁 封装 将类的属性改为私有private，不让对象直接给属性赋值。 在类里写set和get方法，对象调用set方法给属性赋值，get方法获取属性的值，好处是set方法可以限制赋值的范围，保证数据规范性。（eclipse可以根据属性自动生成get和set方法） 构造函数 构造函数是一种特殊方法，主要用来对对象进行初始化，实例化对象时new后边的就是构造函数 构造函数的函数名要与类名一致 一个类可以有多个构造函数，参数不同，实现构造函数的重载 构造函数没有返回值 构造函数默认存在一个无参的，我们也可以写一个无参的覆盖它 实例化对象时调用且值调用一次 如果构造函数调用失败，则无法创建对象 实例化对象时是由java虚拟机调用的构造函数 this关键字 表示当前类的对象，哪个对象调用了this所属的方法，this就代表哪个对象 通过this可以调用当前对象的成员变量和方法 可以在方法里区分成员变量和局部变量 打印this是这个类的地址 this();调用了这个类的无参构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Person &#123; // 姓名 private String name; // 性别 private char sex; // 年龄 private int age; /*定义构造函数*/ //无参数的构造函数 public Person() &#123; System.out.println(\"1、无参构造函数\"); &#125; //一个参数的构造函数 public Person(String _name) &#123; //表示调用了无参的构造函数 this(); name=_name; System.out.println(\"2、 1个参数的构造函数\"); &#125; //三个参数的构造函数 public Person(String name,char sex,int age) &#123; //构造函数中 可以对初始化的内容进行验证 //通过 this区分成员变量与局部变量。。 this.name=name; this.sex=sex; this.age=age; &#125; //show 方法 public void show() &#123; System.out.println(\"大家好，我是\"+name+\"，性别\"+sex+\"，今年\"+age); //在show 方法里面输出this System.out.println(this); &#125; // 自动生成get set方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char _sex) &#123; if (_sex == '男' || _sex == '女') &#123; sex = _sex; &#125; else &#123; System.out.println(\"对不起，设置失败，性别只能是男或女\"); &#125; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; // this 表示的就是当前的对象 this.age = age; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"http://sunzhongyuan.net/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://sunzhongyuan.net/tags/java基础/"}]},{"title":"eclipse相关记录","slug":"eclipse-url","date":"2018-11-26T15:50:03.000Z","updated":"2018-11-27T14:37:41.593Z","comments":true,"path":"2018/11/26/eclipse-url/","link":"","permalink":"http://sunzhongyuan.net/2018/11/26/eclipse-url/","excerpt":"eclipse最新版本下载地址https://www.eclipse.org/downloads/","text":"eclipse最新版本下载地址https://www.eclipse.org/downloads/ eclipse的各种版本号及代号及下载地址https://wiki.eclipse.org/Older_Versions_Of_Eclipse eclipse汉化包地址https://www.eclipse.org/babel/downloads.php eclipse常用快捷键 单行注释//: ctrl+/ command+/ 多行注释/**/:ctrl+shift+/ ctrl+command+/ 取消多行注释:ctrl+shift+\\ ctrl+command+\\ 自动补齐:alt+/ option+/ 快速修正:ctrl+1 command+1 删除:ctrl+d command+d 代码格式化:ctrl+shift+f command+shift+f 实现包的导入，去除无用的包:ctrl+shift+o command+shift+o 打开帮助文档:shift+F2 shift+F2 显示搜索对话框:ctrl+h ctrl+h 上一个/下一个光标位置:alt+left/right","categories":[{"name":"eclipse","slug":"eclipse","permalink":"http://sunzhongyuan.net/categories/eclipse/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://sunzhongyuan.net/tags/eclipse/"}]},{"title":"Java基础回顾1","slug":"javase1","date":"2018-11-25T15:13:48.000Z","updated":"2018-11-26T14:04:41.412Z","comments":true,"path":"2018/11/25/javase1/","link":"","permalink":"http://sunzhongyuan.net/2018/11/25/javase1/","excerpt":"Java的开发环境JDK：Java development kit：开发者工具包JRE：Java Runtime Environment：Java运行环境JVM：Java Virtual Machine：Java虚拟机（所有Java程序都运行在JVM上）JDK包含JRE","text":"Java的开发环境JDK：Java development kit：开发者工具包JRE：Java Runtime Environment：Java运行环境JVM：Java Virtual Machine：Java虚拟机（所有Java程序都运行在JVM上）JDK包含JRE Java程序编译.java java源文件.class 由java源文件编译生成的字节码文件，二进制组成的文件。将字节码文件通过编译器（compiler）解释成JVM能过识别和运行的文件执行javac HelloWorld.java编译java文件生成class文件执行java HelloWorld运行java程序java文件名一定要与类名保持一致 java注释 单行注释 // 多用于说明下一行的功能 多行注释 /* */ 多用于说明一个函数的功能 文档注释 /** */ 多用于说明一个类的功能 12345678910/**** 类说明XXXXXXXX** @author 作者* @version 版本* @see 参考，一个URL链接* @param 参数* @return 返回值*/ 文档注释可以用来生成项目API执行命令javadoc -version -author HelloWorld.java生成 java标识符 字母、数字、下划线和美元符号组成 不能以数字开头 一般不用美元开头，因为美元开头的一般是java自用的 严格区分大小写 不能使用关键字 驼峰命名法 变量：头一个字母小写stdName 类型：首字母大写StudentInfo java关键字 所有java里面被赋予了特殊含义的单词，就叫关键字。 都是小写 分类： 用于定义数据类型:int、class等 数据类型值：true、false、null等 流程控制的：if、for等 访问控制权限：public等 变量、函数修饰的：static等 异常处理的：try、catch等 等等 java数据类型四类八种基本数据类型 整数型： byte：1个字节（8位、8bit、计算机最小存储单元、范围：-128~127） short：2个字节 int：4个字节 long：8个字节 浮点型 float：单精度，4个字节 double：双精度，8个字节 字符型 char：2个字节，一个字符，如：’汉’、’a’ 布尔型 boolean：1个字节，两个值：true、false 引用数据类型 String：一个特殊的类 数组 类 等等 变量变量是可以随着程序的变化而改变赋值12int a = 10;a = 11; 常量一种特殊的变量，只不过是值被设定后，不能改变，用final修饰，比如：1final PI=3.1415926 定义基本数据类型变量三要素： 指明数据类型 变量命名 变量赋值 定义的时候也可以不赋值； 定义常量时不赋值也可以，但是建议定义常量时就给它赋值 定义字符串变量String：引用数据类型，一个特殊的类字符串变量赋值变化时，相当于重新指向了一个对象。 数据类型转换只要是指不同的数据类型之间进行转换 自动类型转换 范围小的数据类型值转换为范围大的数据类型的值byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double例如：123int i = 666;double d;d =i; // 自动类型转换，i转换为double赋值给d，i本身没有变 强制数据类型转换 范围大的数据类型值转换为范围小的数据类型的值溢出不会报错，只是损失了精度例如： 123double d = 666.66;int i;i = (int)d; // 强制类型转换，i打印666，溢出，损失精度 不同数据类型之间进行强制转换例如： 123456String number = \"123\";number = number + 1; // number打印1231，int自动转换为字符串，+表示字符串拼接int i = Integer.parseInt(number); // number别强制类型转换为int类型赋值给ii = i + 1; // i打印1232char c = 'a'int c2i = (int)c; // c2i打印97，为字符a对应的ASCII码 算数运算符 + - * /：0不能作为除数 12345int a = 1;int b = 2:int dvd1 dvd2;dvd1 = a/b; // 结果为0.0dvd2 = a/(b*1.0); // 结果为0.5 % +=：加完之后赋值 -= /= String + 或 += 都表示拼接 自增自减运算符 a++：先使用变量，后加1 a--：先使用变量，后减1 ++a：先加1，后使用变量 --a：先减1，后使用变量123int a = 1;int b = ++a*++a; // b = 2 * 3int c = a++*++a; // c = 3 * 5 比较运算符 &gt; &lt; &gt;= &lt;= == != 逻辑运算符 &amp;：两边都是true，结果才是true，两个都要执行 &amp;&amp;：短路与，第一个是false，结果就是false，第二个就不执行了，可以加快速度。 |：两边有一个是true，结果就是true，两个都要执行 ||：短路或，第一个是ture，结果就是true，第二个就不执行了 ! 位运算符主要针对二进制数，只有0、1两种形态，首先将十进制数转换为2进制，然后根据规则按位运算，提高运算速度，多应用于偏硬件 &amp;：位与，两个数同时为1，则为1，否则为0 |：位或，两个数中有一个为1，则为1，否则为0 ^：异或，相同为0，不同为1 ~：取反，按位取相反的值 负数的二进制表示：最高位是1则是负数，是0则是正数如果负数单纯是把最高位变为1的话，在运算中会出现不是我们想要的值，所以引入了：原码，反码，补码正数的原码，反码，补码都一样负数的反码是对除了符号位（最高位）对原码取反，补码是对反码+1例如：-5原码：1000 0000 0000 0101反码：1111 1111 1111 1010补码：1111 1111 1111 1011计算机运算用的是补码将补码保留符号位，其他位按位取反加1得到原码 &gt;&gt;：右移运算符，规律：相当于除以2取整 &lt;&lt;：左移运算符，规律：相当于乘以2 当移动位数超过实际有效位数时，对移动位数取余 比如实际有效位数为32，移动位数100，则移动100%32位 &gt;&gt;&gt;：无符号右移，例如：-10&gt;&gt;&gt;1 先取补码（除符号位以外其他位取反加1） 对补码高位补0，右移1位 得到结果，由负数变成了正数 12345678910111213int a = 5; // 00000101int b = 1; // 00000001int c = 21; // 00010101int d = -10; // 10000000 00000000 00000000 00001010int i;i = a&amp;b; // 1，0001i = a|b; // 5，0101i = a^b; // 4，0100i = ~b; // -2，11111111 11111111 11111111 11111110i = c&gt;&gt;1; // 10，00001010i = c&lt;&lt;1; // 42，00101010i = d&gt;&gt;1; // -5，10000000 00000000 00000000 00000101i = d&gt;&gt;&gt;1; // 2147483643，011111111 11111111 11111111 1111011 三元运算符布尔表达式?结果1:结果2true执行结果1false执行结果2 转义运算符八进制转义\\ + 1到3位八进制数字，范围001~377char c = &#39;\\101&#39;表示A（大写A对应的ASCII码是65，转换成八进制是101） Unicode转义字符（十六进制转义）\\u + 4位十六进制数字，范围0~65535char c = &#39;\\u0021&#39;表示! 特殊字符 \\&quot;：表示双引号 \\&#39;：表示单引号 \\\\：反斜线 控制字符 \\r：回车 \\n：换行 \\t：tab \\b：退格 程序控制语句（顺序、条件、循环） if条件语句 switch条件语句 for循环语句 while循环 dowhile循环 break continue return1234567//打印九九乘法表for(int m = 1; m &lt;= 9; m++)&#123; for(int n = 1; n &lt;= m; n++)&#123; System.out.print(n+\"*\"+m+\"=\"+m*n+\"\\t\"); &#125; System.out.println();&#125; 数组 数组有索引，从0开始，代表不同的数值 数组的长度固定 一维数组 声明数组声明数组变量 123int[] array; //或者int array[]; 初始化数组确定数组的大小 12345// 可以声明时直接确定数组大小int[] array = new int[3];// 或者int[] array;array = new int[3]; 数组的赋值给数组的元素赋值 12345678// 静态赋值，声明时确定大小同时给元素赋值int[] array = new int[]&#123;1,2,3&#125;;// 或者int[] array = &#123;1,2,3&#125;;// 动态赋值array[0]=1;array[1]=2;array[2]=3; 123456789// 找出数组的最大值int[] array = new int[]&#123;3,5,1,7,8,5,9&#125;;int max = array[0];for(int m = 1; m &lt; array.length; m++)&#123; if(max&lt;array[m])&#123; max = array[m]; &#125;&#125;System.out.println(max); 二维数组声明初始化赋值参照一维数组int[][] d_arr = new int[3][2]可以理解为一个大小为3的一维数组里的元素的数据类型是大小为2的一维数组 12345678910111213141516171819202122232425// 矩阵相乘 A*B A的列数 要等于 B的行数，得到的矩阵为A的行数 B的列数int[][] A=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int[][] B=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;int C_row=A.length;int C_col=B[0].length;int[][] C=new int[C_row][C_col];for(int i=0;i&lt;C_row;i++)&#123; for(int j=0;j&lt;C_col;j++)&#123; for(int k=0;k&lt;B.length;k++)&#123; C[i][j]+=A[i][k]*B[k][j]; &#125; &#125;&#125;for(int i=0;i&lt;C_row;i++)&#123; for(int j=0;j&lt;C_col;j++)&#123; System.out.print(C[i][j]+\"\\t\"); &#125; System.out.println();&#125;/*** 输出* 7 10* 15 22* 23 34*/ 方法方法的定义方法的重载略","categories":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/categories/java/"},{"name":"java基础","slug":"java/java基础","permalink":"http://sunzhongyuan.net/categories/java/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://sunzhongyuan.net/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"http://sunzhongyuan.net/tags/java基础/"}]},{"title":"Hadoop学习笔记1","slug":"hadoop1","date":"2018-11-07T14:44:00.000Z","updated":"2018-11-20T13:16:05.409Z","comments":true,"path":"2018/11/07/hadoop1/","link":"","permalink":"http://sunzhongyuan.net/2018/11/07/hadoop1/","excerpt":"大数据的四个特征 Volume 海量的数据规模（TB、PB、EB） variety 多样的数据类型（结构化、非结构化、半结构化、其他） velocity 快速的数据流转（流、实时、近实时、批量） value 发现数据价值","text":"大数据的四个特征 Volume 海量的数据规模（TB、PB、EB） variety 多样的数据类型（结构化、非结构化、半结构化、其他） velocity 快速的数据流转（流、实时、近实时、批量） value 发现数据价值 大数据要解决的问题 从海量的多样的数据中发现数据价值 大数据涉及到的技术 数据采集 数据存储 数据处理、分析、挖掘 可视化 大数据在技术架构上带来的挑战 对现有数据库管理技术的挑战，大量的数据 讲点数据库技术并没有考虑数据的多类别 实时性的技术挑战，如电商实时推荐 网络架构、数据中心、运维的挑战 大数据带来的其他挑战 数据隐私 数据源的复杂多样 如何对大数据进行存储和分析 谷歌推出大数据技术解决以下三个系统瓶颈 存储容量 GFS 读写速度 BigTable 计算效率 MapReduce Hadoop根据谷歌技术论文开源实现 存储容量 HDFS 读写速度 HBase 计算效率 MapReduce Hadoop概述 可靠的，可扩展的，分布式的 分布式存储+分布式计算平台 大数据能做什么 搭建大型数据仓库，PB级数据的存储、处理、分析、统计等业务 搜索引擎 日志分析 商业智能 数据挖掘 分布式文件系统HDFSHDFS特点 水平扩展性 容错性 将文件切分成指定大小的数据块并以多副本的形式存储在多个机器上，一个数据块默认128MB 如下图，一个文件可能被分成两个数据块，这两个数据块以多副本的形式存储在多个机器上 如何切分、如何多副本、如何容错等操作对用户是透明的，不需要用户处理，用户仍指操作一个完整的文件即可 海量数量存储 资源调度系统YARN 负责整个集群资源的管理和调度 运行一个job需要多少资源由YARN负责管理和调度 YARN的特点 水平扩展性 容错性 多框架资源统一调度 分布式计算框架MapReduceMapReduce特点 水平扩展性 容错性 海量数据离线处理 MapReduce数据流 Hadoop的优势可靠性 数据存储：数据块多副本 数据计算：重新调度作业计算 扩展性 存储、计算资源不够时，可以横向的线性扩展机器 一个集群中可以包含数以千计的节点 其他优势 存储在廉价机器上，降低成本 成熟的生态圈，很多框架 Hadoop生态系统 Hadoop生态系统的特点 开源、社区活跃 囊括了大数据处理的方方面面 成熟的生态圈 Hadoop常用发行版及选型Apache Hadoop 单个jar包没问题，多个jar包组合使用会产生冲突 CDH：Cloudera Distributed Hadoop 通过浏览器页面安装，配置、升级简单 所有jar包都选择相同的CDH版本号，这样就不会产生冲突 非开源 下载地址 HDP：Hortonworks Data Platform 开源 较CDH安装升级麻烦","categories":[{"name":"大数据","slug":"大数据","permalink":"http://sunzhongyuan.net/categories/大数据/"},{"name":"Hadoop","slug":"大数据/Hadoop","permalink":"http://sunzhongyuan.net/categories/大数据/Hadoop/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://sunzhongyuan.net/tags/Hadoop/"}]},{"title":"正则表达式","slug":"regex","date":"2018-09-23T12:28:24.000Z","updated":"2018-11-04T14:30:30.913Z","comments":true,"path":"2018/09/23/regex/","link":"","permalink":"http://sunzhongyuan.net/2018/09/23/regex/","excerpt":"正则表达式 可以理解为一个模板，用这个模板匹配过滤数据 正则表达式引擎 一套负责解释正则表达式模式并使用这些模板进行文本匹配的底层软件 在linux系统中流行的两种正则表达式引擎 POSIX基础正则表达式（basic regular expression，BRE）引擎 POSIX扩展正则表达式（extended regular expression，ERE）引擎 大多数linux工具都至少符合BRE引擎规范，但是有些工具（比如sed）只符合了BRE的子集，这是出于速度的考虑。","text":"正则表达式 可以理解为一个模板，用这个模板匹配过滤数据 正则表达式引擎 一套负责解释正则表达式模式并使用这些模板进行文本匹配的底层软件 在linux系统中流行的两种正则表达式引擎 POSIX基础正则表达式（basic regular expression，BRE）引擎 POSIX扩展正则表达式（extended regular expression，ERE）引擎 大多数linux工具都至少符合BRE引擎规范，但是有些工具（比如sed）只符合了BRE的子集，这是出于速度的考虑。 BRE模式 纯文本 特殊字符（. * [] ^ $ {} \\ + ? | ()） \\：转义字符，用来转义这些特殊字符，另外sed中的/也需要转义echo &quot;3/2&quot;|sed -n &#39;/\\//p&#39; ^：行首，用来定义文本行的行首开始的模式，如果放到模式开头之外的其他位置，那么它就是一个普通字符了 $：行尾，用来定义文本行的行尾结束的模式，如果放到模式结尾之外的其他位置，那么它就是一个普通字符了 ^$：空行 .：除换行符之外的任意单个字符 []：字符组，可以作为一个特殊的通配符，与.类似，.通配任意单个字符，[12ab]表示通配1、2、a、b [^]：排除型字符组，[^12ab]表示通配处理1、2、a、b的其他任意字符 [-]：区间型字符组，[0-9]表示通配数字，[a-ce-h]表示通配a到c和e到h的两个区间 [[:alpha:]]：匹配任意字母字符a~z、A~Z [[:alnum:]]：匹配任意字母数字字符0~9、a~z、A~Z [[:blank:]]：匹配空格或制表符 [[:digit:]]：匹配任意数字字符0~9 [[:lower:]]：匹配任意小写字母字符a~z [[:upper:]]：匹配任意大写字母字符A~Z [[:print:]]：匹配任意可打印字符 [[:punct:]]：匹配任意标点符号 [[:space:]]：匹配任意空白字符：空格、制表符、NL、FF、VT、CR * *在正则表达式以为多被定义为通配任意个任意字符，而在正则表达式里则不同，在正则表达式里*要放置在一个字符后面，表明该字符可以出现0次或多次 1echo \"abc\"|sed -n '/d*/p' #打印abc，因为d可以出现0次 如果限制了位置区间，这个位置区间内不能出现该字符以外其他字符，a[123]*ba和b之间只能出现1、2、3多次或0次，不可以出现字符组以外的字符 12echo \"eabcf\" | sed -n '/ea*f/p' # 不打印，e和f之间只能出现a多次或0次，这里出现了其他字符b和c，所以不打印echo \"eabcf\" | sed -n '/e[abcd]*f/p' # 打印eacbdf *前放置的字符有下面几种情况： 没有字符或部分特殊字符如果*前面没有字符或者前边是部分特殊字符，那么它就是一个普通字符了 12echo \"ab*c\"|sed -n '/*/p' # 打印ab*c，*是一个普通字符echo \"*abc\"|sed -n '/^*/p' # 打印*abc，*是一个普通字符 普通字符表示该字符必须出现0次或多次 123echo \"abc\"|sed -n '/d*/p' # 打印abc，d可以出现0次echo \"abdddc\"|sed -n '/d*/p' # 打印abdddc，d可以出现多次echo \"abdc\"|sed -n '/ad*c/p' # 不打印，a和c之间只能出现d0次或多次，不可以出现其他字符 特殊字符.*表示任意字符出现0次或多次 1echo \"abdc\"|sed -n '/.*/p' # 打印abdc 字符组[][]*表示字符组内的任意字符出现0次或多次 12echo \"abdc\"|sed -n '/[2e42]*/p' # 打印abdcecho \"abcdef\"|sed -n '/a[bcd]*f/p' # 不打印 ERE模式 特殊字符（. * [] ^ $ {} \\ + ? | ()） ?：类似*，不同的是?前面的字符可以出现0次或1次（?代表一个字符，*可以代表多个字符） []?：字符组中的多个字符只能出现一个，并且这个字符只能出现0次或1次 1234echo \"asdf\"|awk '/a[sd]?f/&#123;print $0&#125;' # 不打印，s和d只能出现一个echo \"assf\"|awk '/a[sd]?f/&#123;print $0&#125;' # 不打印，s只能出现一次echo \"asf\"|awk '/a[sd]?f/&#123;print $0&#125;' # 打印asf，出现1次echo \"af\"|awk '/a[sd]?f/&#123;print $0&#125;' # 打印af，出现0次 +：类似*，不同的是+前面的字符可以出现1次或多次 []+：字符组中的多个字符可以出现1次或多次123echo \"af\"|awk '/a[sd]+f/&#123;print $0&#125;' # 不打印，出现0次不可以echo \"asf\"|awk '/a[sd]+f/&#123;print $0&#125;' # 打印asf，出现1次可以echo \"asdf\"|awk '/a[sd]+f/&#123;print $0&#125;' # 打印asdf，出现多次可以 {}：用来限制字符出现的次数 12345678echo \"asf\"|awk '/as&#123;1&#125;f/&#123;print $0&#125;' # 打印asfecho \"assf\"|awk '/as&#123;1&#125;f/&#123;print $0&#125;' # 不打印echo \"assf\"|awk '/as&#123;1,2&#125;f/&#123;print $0&#125;' # 打印assf，s可以出现1次到2次 echo \"asssf\"|awk '/as&#123;1,2&#125;f/&#123;print $0&#125;' # 不打印echo \"aqwef\"|awk '/a.&#123;1,3&#125;f/&#123;print $0&#125;' # 打印aqwef，任意字符出现1次到3次echo \"asf\"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 打印asfecho \"asdf\"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 打印asdfecho \"assdf\"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 不打印 |：或/ab|ac/：仅匹配ab或ac ()：分组/(abc)?/：将abc看做一个字符使用，abc可以出现0次或1次 PS. ?：出现0次或1次 +：出现1次或多次 *：出现0次或多次 邮件正则表达式：^([a-zA-Z0-9_\\-\\.\\+]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$","categories":[{"name":"linux","slug":"linux","permalink":"http://sunzhongyuan.net/categories/linux/"}],"tags":[{"name":"regex","slug":"regex","permalink":"http://sunzhongyuan.net/tags/regex/"}]},{"title":"sed流编辑器","slug":"sed","date":"2018-09-16T12:02:01.000Z","updated":"2018-10-28T12:45:50.816Z","comments":true,"path":"2018/09/16/sed/","link":"","permalink":"http://sunzhongyuan.net/2018/09/16/sed/","excerpt":"sed流编辑器 与交互式文本编辑器(如vim)不同，交互式文本编辑器用键盘来插入、修改和删除数据；而流编辑器则是通过预先设置的规则来编辑数据流。 sed编辑器将修改后的数据输出到stdout标准输出，不会改变原始数据。 sed命令的格式1sed options script file # sed 选项 '[地址]命令' 文件","text":"sed流编辑器 与交互式文本编辑器(如vim)不同，交互式文本编辑器用键盘来插入、修改和删除数据；而流编辑器则是通过预先设置的规则来编辑数据流。 sed编辑器将修改后的数据输出到stdout标准输出，不会改变原始数据。 sed命令的格式1sed options script file # sed 选项 '[地址]命令' 文件 eg.删除test.txt中所有#开头的行1sed -e '/^#/d' test.txt # -e可以省略 sed会依次执行下列操作： 将test.txt作为输入，从中读取一行数据到sed内部的一个模式缓冲区，也可以从命令管道读取cat test.txt|sed -e &#39;/^#/d&#39; 根据设置的地址/^#/匹配读取的这一行个，判断当前行是否需要处理 如果需要处理则将这一行执行命令d 将模式缓冲区内的这一行输出到stdout标准输入（屏幕），不会改变原始数据 重复上述步骤再从输入读取一行进行匹配、修改、输出，直到处理完所有行 options: 123-n 禁止sed编辑器输出-e script 将script中指定的命令添加到已有的命令中（缺省值）-f file 将file中指定的命令添加到已有的命令中 script: script一般建议用单引号&#39;括起来 script常由地址（行寻址）和命令组成，地址控制了将命令应用到哪些行，缺省为所有行。 行寻址： 如果想让命令作用在某一行，可以在命令前加上行寻址 行寻址有两种形式： 数字方式的行寻址 123sed '2s/a/111/g' test.txt # 只替换第二行sed '2,4s/a/111/g' test.txt # 替换2，3，4行sed '2,$s/a/111/g' test.txt # 替换2到最后一行 使用文本模式过滤器 12/pattern/command # /模式/命令/pattern/,/pattern/command # /模式1/,/模式2/命令 eg. 1234567# 只替换#开头的行sed '/^#/s/a/111/g' test.txt # 替换所有模式1到模式2区间的行，前后包含，可能有多个区间，# 模式1代表开始，模式2代表结束，# 如果没有代表结束的模式2则一直替换到最后一行sed '/a/,/b/s/a/111/g' test.txt sed支持多个命令组合使用： 单个命令 1sed 's/a/111/g' test.txt 多个命令 1234567sed 's/a/111/g; s/b/222/g' test.txt # 注意格式，分号前不能有空格sed -e 's/a/111/g' -e 's/b/222/g' test.txt # 用两个-e实现多命令sed -f aa.sed test.txt # 将多个命令写在一个文件里，一行一个命令，用-f引用这个文件sed ' # 注意格式，输入第一个单引号后可以回车，一行一个命令&gt; s/a/111/g&gt; s/b/222/g&gt; ' test.txt # 输入另一个单引号，表示命令行输入完毕，在这一行要结束整个sed命令 一个地址执行多个命令： 在多个命令组合的基础上加上行寻址，然后把命令用{}括起来即可 12345address&#123; command1 command2 command3&#125; eg. 123456789101112131415161718192021222324252627282930zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '2&#123;&gt; s/line/abcd/g&gt; s/#/!/g&gt; &#125;' test.txtline 1abcd 2!#line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '/^#/&#123;&gt; s/line/abcd/g&gt; s/#/!/g&gt; &#125;' test.txtline 1line 2#!abcd 3line #4!ine 5line 6 sed常用的命令替换s1s/pattern/replacement/flags # s/模式/代替者/替换标记 模式可以理解为正则表达式，在当前行匹配字符串，将匹配的字符串用代替者替换替换标记有四种： 数字：替换标记缺省值为1，表示替换每一行中的第一处模式匹配的地方，指定几，就替换每行中第几处模式匹配的地方 g：替换每行中所有模式匹配的地方，就是替换所有匹配上的字符串 p：这个标记通常和sed的-n选项结合使用，-n会禁止sed编辑器输出，但p会输出修改过的行，结合两个就是只输出被替换命令修改过的行；如果没有-n选项，被修改过的行会打印两遍 w file：功能与p类似，p是打印，w是写到文件里，如果文件存在则覆盖写入 字符串分隔符/可以用其他字符替代： 一个模式如果是路径，路径中的/需要用\\转码eg.将/etc/passwd文件中的/bin/bash替换为/bin/csh 1sed 's/\\/bin\\/bash/\\/bin\\/csh/g' /etc/passwd 这样转码就麻烦，不便于书写和阅读，所以sed编辑器允许用其他字符代替字符串分隔符/ 1sed 's!/bin/bash!/bin/csh!g' /etc/passwd 删除行d12345sed 'd' test.txt # 删除所有行sed '2d' test.txt # 删除第二行sed '2,$' test.txt # 删除第二行到最后一行sed '/a/d' test.txt # 删除包含a的行sed '/a/,/b/d' test.txt # 删除包含a的行到包含b的行这个区间的所有行，没有包含b的行则会删除到最后一行，谨慎使用 插入a、i sed的插入只能以行为单位插入 i：指定行前插入 a：指定行后插入 123sed '[address]command\\new line1\\new line2' eg.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354zyzy@zyzy:~/Templates$ echo \"line 1\" | sed 'i\\&gt; line 2\\&gt; line 3'line 2line 3line 1zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '1i\\&gt; inserted line a\\&gt; inserted line b' test.txtinserted line ainserted line bline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '$a\\&gt; inserted line a\\&gt; inserted line b&gt; ' test.txtline 1line 2##line 3line #4#ine 5line 6inserted line ainserted line bzyzy@zyzy:~/Templates$ sed 'a\\!!!!!!!' test.txtline 1!!!!!!!line 2#!!!!!!!#line 3!!!!!!!line #4!!!!!!!#ine 5!!!!!!!!!!!!!!line 6!!!!!!! 修改c12345678910111213141516171819202122232425262728293031323334353637383940414243444546zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed 'c\\aaaa' test.txtaaaaaaaaaaaaaaaaaaaaaaaaaaaazyzy@zyzy:~/Templates$ sed '2c\\&gt; aaaaa\\&gt; bbbbbbbb' test.txtline 1aaaaabbbbbbbb#line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '2,5c\\aaaaaaaaa' test.txtline 1aaaaaaaaaline 6zyzy@zyzy:~/Templates$ sed '/#/c\\&gt; aaaaaa\\&gt; bbbbbbbbb' test.txtline 1aaaaaabbbbbbbbbaaaaaabbbbbbbbbaaaaaabbbbbbbbbaaaaaabbbbbbbbbline 6 转换ysed中唯一一个处理单个字符的命令 1[address]y/inchars/outchars/ inchars和outchars一对一映射，如果inchars和outchars长度不同，则会报错。eg. 1234567891011121314151617181920212223242526272829303132zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed 'y/ln/89/' test.txt8i9e 18i9e 2##8i9e 38i9e #4#i9e 58i9e 6zyzy@zyzy:~/Templates$ sed '2,3y/ln/89/' test.txtline 18i9e 2##8i9e 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '/line 3/y/ln/89/' test.txtline 1line 2##8i9e 3line #4#ine 5line 6 打印打印行p123456789101112131415161718192021222324zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n '2,4p' test.txtline 2##line 3line #4zyzy@zyzy:~/Templates$ sed -n '/#/&#123;&gt; p&gt; s/#//p&gt; &#125;' test.txtline 2#line 2#line 3line 3line #4line 4#ine 5ine 5 打印行号=123456zyzy@zyzy:~/Templates$ sed -n '/line 3/&#123;&gt; =&gt; p&gt; &#125;' test.txt3#line 3 列出行l打印数据流中的文本和不可打印的ascii字符12345678910111213141516zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n 'l' test.txtline 1$line 2#$#line 3$line #4$#ine 5$\\t\\t$line 6$ \\t：制表符tab$：换行符 写入文件w1[address]w filename 覆盖写入文件filename，文件不存在则创建12345678910111213zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n '2,4w test2.txt' test.txtzyzy@zyzy:~/Templates$ cat test2.txtline 2##line 3line #4 读取文件r将文件内容插入到数据流中1[address]r filename 将filename中的内容写入到数据流中123456789101112131415161718192021222324252627282930313233343536zyzy@zyzy:~/Templates$ cat test2.txtline 2##line 3line #4zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '$r test2.txt' test.txtline 1line 2##line 3line #4#ine 5line 6line 2##line 3line #4zyzy@zyzy:~/Templates$ sed '5&#123;&gt; r test2.txt&gt; d&gt; &#125;' test.txtline 1line 2##line 3line #4line 2##line 3line #4line 6","categories":[{"name":"linux","slug":"linux","permalink":"http://sunzhongyuan.net/categories/linux/"},{"name":"shell","slug":"linux/shell","permalink":"http://sunzhongyuan.net/categories/linux/shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://sunzhongyuan.net/tags/linux/"},{"name":"sed","slug":"sed","permalink":"http://sunzhongyuan.net/tags/sed/"},{"name":"shell","slug":"shell","permalink":"http://sunzhongyuan.net/tags/shell/"}]},{"title":"linux开启ssh服务","slug":"sshd","date":"2018-09-01T16:29:56.000Z","updated":"2018-10-14T02:45:29.490Z","comments":true,"path":"2018/09/02/sshd/","link":"","permalink":"http://sunzhongyuan.net/2018/09/02/sshd/","excerpt":"首先确认系统是否安装了ssh服务输入service sshd status命令查看1234root@zyzy:/etc/ssh# service sshd status● sshd.service Loaded: not-found (Reason: No such file or directory) Active: inactive (dead) Loaded: not-found (Reason: No such file or directory) 说明未安装ssh服务 Active: inactive (dead)说明ssh服务未启动","text":"首先确认系统是否安装了ssh服务输入service sshd status命令查看1234root@zyzy:/etc/ssh# service sshd status● sshd.service Loaded: not-found (Reason: No such file or directory) Active: inactive (dead) Loaded: not-found (Reason: No such file or directory) 说明未安装ssh服务 Active: inactive (dead)说明ssh服务未启动 安装ssh服务sudo apt-get install openssh-server 其他系统如redhat、centos执行以下命令 sudo yum install openssh-server 安装成功后可用service sshd status查看ssh服务是否启动 启动ssh服务service sshd start 使用ssh服务另一台机器执行ssh user@ip回车输入密码即可 PS. 查看ipifconfig 更新root密码sudo passwd root","categories":[{"name":"linux","slug":"linux","permalink":"http://sunzhongyuan.net/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://sunzhongyuan.net/tags/linux/"},{"name":"ssh","slug":"ssh","permalink":"http://sunzhongyuan.net/tags/ssh/"}]},{"title":"mac安装linux虚拟机","slug":"parallels","date":"2018-09-01T02:29:34.000Z","updated":"2018-10-24T15:40:50.863Z","comments":true,"path":"2018/09/01/parallels/","link":"","permalink":"http://sunzhongyuan.net/2018/09/01/parallels/","excerpt":"推荐parallelsMac parallels desktop 13破解下载及安装 感谢！！！","text":"推荐parallelsMac parallels desktop 13破解下载及安装 感谢！！！","categories":[{"name":"Mac","slug":"Mac","permalink":"http://sunzhongyuan.net/categories/Mac/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://sunzhongyuan.net/tags/macOS/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://sunzhongyuan.net/tags/虚拟机/"}]},{"title":"mac安装Homebrew","slug":"Homebrew","date":"2018-08-26T11:02:54.000Z","updated":"2018-10-24T15:40:40.987Z","comments":true,"path":"2018/08/26/Homebrew/","link":"","permalink":"http://sunzhongyuan.net/2018/08/26/Homebrew/","excerpt":"什么是Homebrew 维基百科这样说：Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程。[更多] 说白了Homebrew就是Mac系统下的包管理器，相当于Linux的apt-get。 和Linux的包管理器一样，Homebrew提供了简单的命令实现安装、更新、卸载包，并且还能维护包之间的依赖关系，能够帮助你安装一个包时自动安装它的依赖包。 使用Homebrew能安装什么 官网有这样一句话：使用 Homebrew 安装 Apple 没有预装但 你需要的东西。 也可以使用Homebrew提供的命令，通过关键字进行模糊搜索123456mac:~ zyzy$ brew search atom==&gt; Formulaeatomicparsley datomic libatomic_ops mediatomb sratom==&gt; Casks # 有图形界面的软件homebrew/cask-versions/atom-beta homebrew/cask/atom","text":"什么是Homebrew 维基百科这样说：Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程。[更多] 说白了Homebrew就是Mac系统下的包管理器，相当于Linux的apt-get。 和Linux的包管理器一样，Homebrew提供了简单的命令实现安装、更新、卸载包，并且还能维护包之间的依赖关系，能够帮助你安装一个包时自动安装它的依赖包。 使用Homebrew能安装什么 官网有这样一句话：使用 Homebrew 安装 Apple 没有预装但 你需要的东西。 也可以使用Homebrew提供的命令，通过关键字进行模糊搜索123456mac:~ zyzy$ brew search atom==&gt; Formulaeatomicparsley datomic libatomic_ops mediatomb sratom==&gt; Casks # 有图形界面的软件homebrew/cask-versions/atom-beta homebrew/cask/atom 安装Homebrew1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 更新Homebrew1brew update 卸载Homebrew1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 使用Homebrew12345brew install &lt;packageName&gt; # 安装包brew uninstall &lt;packageName&gt; # 卸载包brew search &lt;packageName&gt; # 查询包brew list # 查询已安装的包brew info &lt;packageName&gt; # 查看包信息 PS. 正恶补sed命令，然而发现Mac和Linux上的sed命令有些差距，为降低学习成本，决定在Mac上安装gnu-sed。 12345678910111213141516171819202122232425262728mac:~ zyzy$ brew install gnu-sed --with-default-namesUpdating Homebrew...==&gt; Auto-updated Homebrew!Updated 1 tap (homebrew/core).No changes to formulae.==&gt; Downloading https://ftp.gnu.org/gnu/sed/sed-4.5.tar.xz######################################################################## 100.0%==&gt; ./configure --prefix=/usr/local/Cellar/gnu-sed/4.5==&gt; make install🍺 /usr/local/Cellar/gnu-sed/4.5: 10 files, 528.5KB, built in 1 minute 56 secondsmac:~ zyzy$ cd /usr/local/Cellar/gnu-sed/4.5mac:4.5 zyzy$ ltotal 352-rw-r--r-- 1 zyzy admin 318 8 28 2016 AUTHORS-rw-r--r-- 1 zyzy admin 731 1 17 2017 README-rw-r--r-- 1 zyzy admin 35151 3 7 21:59 COPYING-rw-r--r-- 1 zyzy admin 24088 4 1 09:39 NEWS-rw-r--r-- 1 zyzy admin 103611 4 1 09:40 ChangeLogdrwxr-xr-x 4 zyzy admin 128 8 26 20:59 sharedrwxr-xr-x 3 zyzy admin 96 8 26 20:59 bin-rw-r--r-- 1 zyzy admin 595 8 26 20:59 INSTALL_RECEIPT.jsonmac:4.5 zyzy$ cd binmac:bin zyzy$ ltotal 320-r-xr-xr-x 1 zyzy admin 161660 8 26 20:59 sedmac:bin zyzy$ pwd/usr/local/Cellar/gnu-sed/4.5/bin 将/usr/local/Cellar/gnu-sed/4.5/bin加到PATH即可 --with-default-names会阻止homebrew添加一个”g”到新安装的命令前。这样我们就能使用这些命令的通用名字，从而覆盖掉OS X预装的命令。","categories":[{"name":"Mac","slug":"Mac","permalink":"http://sunzhongyuan.net/categories/Mac/"}],"tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://sunzhongyuan.net/tags/Homebrew/"},{"name":"macOS","slug":"macOS","permalink":"http://sunzhongyuan.net/tags/macOS/"},{"name":"brew","slug":"brew","permalink":"http://sunzhongyuan.net/tags/brew/"}]},{"title":"python必备-virtualenv和virtualenvwrapper总结","slug":"Virtualenv","date":"2018-08-18T05:57:16.000Z","updated":"2018-08-20T15:38:37.401Z","comments":true,"path":"2018/08/18/Virtualenv/","link":"","permalink":"http://sunzhongyuan.net/2018/08/18/Virtualenv/","excerpt":"Virtualenv python项目与Java项目不同，Java的每一个项目都会将需要的库重新引用到自己的项目文件夹中； 而在同一开发环境中，python的所有项目都共用一个开发库，将多个项目的包混在一起，这样不利于管理，还会造成包冲突； 所以我们需要用到Virtualenv，它用于创建独立的python开发环境； 可以保证每一个项目都有独立的开发环境，包括不同的python版本。 virtualenvwrapper 它是基于virtualenv之上的管理工具，用来统一管理这些独立的开发环境（虚拟环境）。 快速上手0.安装Virtualenv1pip install virtualenv","text":"Virtualenv python项目与Java项目不同，Java的每一个项目都会将需要的库重新引用到自己的项目文件夹中； 而在同一开发环境中，python的所有项目都共用一个开发库，将多个项目的包混在一起，这样不利于管理，还会造成包冲突； 所以我们需要用到Virtualenv，它用于创建独立的python开发环境； 可以保证每一个项目都有独立的开发环境，包括不同的python版本。 virtualenvwrapper 它是基于virtualenv之上的管理工具，用来统一管理这些独立的开发环境（虚拟环境）。 快速上手0.安装Virtualenv1pip install virtualenv 1.安装virtualenvwrapper注意请先切换到用户目录，并退出虚拟环境后安装，否则会安装到虚拟环境；1pip install virtualenvwrapper Windows执行这个，Windows版官方文档1pip install virtualenvwrapper-win 2.初始化virtualenvwrapper1source /usr/local/bin/virtualenvwrapper.sh 初始化执行一次即可。 还可以将该命令添加到~/.bashrc或~/.profie或~/.bash_profile等shell启动文件中，以便登陆shell后可直接使用virtualenvwrapper提供的命令。 3.自定义WORKON_HOME virtualenvwrapper默认将所有的虚拟环境放在~/.virtualenvs目录下管理。 可以修改环境变量WORKON_HOME来指定虚拟环境的保存目录。 将以下命令添加到~/.bashrc或~/.profie或~/.bash_profile等shell启动文件中 12export WORKON_HOME=$HOME/envssource /usr/local/bin/virtualenvwrapper.sh 然后source一下让环境变量生效 1source ~/.bash_profile 4.创建虚拟环境1234mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] ENVNAME 直接执行mkvirtualenv可查看命令选项 mkvirtualenv是virtualenvwrapper创建虚拟环境的命令 virtualenv是Virtualenv创建虚拟环境的命令 mkvirtualenv继承了virtualenv命令的所有选项 virtualenv命令选项说明文档https://virtualenv.pypa.io/en/stable/reference/#virtualenv-command 123456789101112mac:~ zyzy$ mkvirtualenv -p python3 --no-site-packages testenv3.6Running virtualenv with interpreter /usr/local/bin/python3Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'New python executable in /Users/zyzy/workspaces/testenv3.6/bin/python3Also creating executable in /Users/zyzy/workspaces/testenv3.6/bin/pythonInstalling setuptools, pip, wheel...done.virtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/predeactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/postdeactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/preactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/postactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/get_env_details(testenv3.6) mac:~ zyzy$ 注意命令行多了(testenv3.6)前缀，说明虚拟环境创建成功，并且已经切换到了虚拟环境 在这个环境里可以用pip安装这个项目需要的包了，不会影响到其他项目 5.退出虚拟环境1deactivate 6.查看有哪些虚拟环境1workon 7.进入虚拟环境1workon testenv3.6 8.删除虚拟环境1rmvirtualenv testenv3.6 也可以直接删除testenv3.6目录 9.其他命令 showvirtualenv [env] 显示指定环境的详情。 cpvirtualenv [source] [dest] 复制一份虚拟环境。 add2virtualenv [dir] [dir] 把指定的目录加入当前使用的环境的path中，这常使用于在多个project里面同时使用一个较大的库的情况。 PS.生成requirements.txt python项目必须包含一个requirements.txt文件，用于记录所有依赖包及其精确的版本号，以便新环境部署。 生成requirements.txt很简单， 首先切换到虚拟环境， 用pip list可以查看当前虚拟环境安装的包，但是这里有三个默认包我们不需要记录； 所以我们用pip freeze命令查看，这个命令不显示默认包，直接将这个命令的输出结果重定向到requirements.txt文件即可 12pip freeze &gt; requirements.txt # 生成requirements.txtpip install -r requirements.txt # 从requirements.txt安装依赖 如何部署没有requirements.txt的项目 可以安装第三方工具pipreqs生成requirements.txt； 这个工具通过扫描源码生成依赖包，所以要切换到项目目录执行， 可能有些不全，需要自己手动调整。 12pip install pipreqs # 安装pipreqspipreqs ./ # 生成requirements.txt","categories":[{"name":"python","slug":"python","permalink":"http://sunzhongyuan.net/categories/python/"},{"name":"Virtualenv","slug":"python/Virtualenv","permalink":"http://sunzhongyuan.net/categories/python/Virtualenv/"}],"tags":[{"name":"Virtualenv","slug":"Virtualenv","permalink":"http://sunzhongyuan.net/tags/Virtualenv/"}]},{"title":"个人博客 GitHub Pages + Hexo","slug":"hexo","date":"2018-08-11T17:30:35.000Z","updated":"2018-08-13T14:06:48.351Z","comments":true,"path":"2018/08/12/hexo/","link":"","permalink":"http://sunzhongyuan.net/2018/08/12/hexo/","excerpt":"0.用hexo在本地创建个人博客创建方法参照：hexo中文官方文档 1.在GitHub上创建一个项目GitHub Pages文档，可以了解一下，这里只用了第一步，创建一个项目。","text":"0.用hexo在本地创建个人博客创建方法参照：hexo中文官方文档 1.在GitHub上创建一个项目GitHub Pages文档，可以了解一下，这里只用了第一步，创建一个项目。 2.将本地博客上传到GitHub上 将本地git与GitHub绑定（通过SSH） 安装插件npm install hexo-deployer-git --save 编辑Hexo的_config.yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:sunzhongyuan/sunzhongyuan.github.io.git branch: master 执行hexo d -g将生成html文件上传到GitHub 地址栏输入sunzhongyuan.github.io即可访问个人博客 3.绑定个人域名 设置项目sunzhongyuan.github.io 设置个人域名DNS解析 PS.每次执行hexo d -g上传代码后都要重新设置个人域名问题 在hexo目录下的source文件中加入一个文件名为CNAME, 里面写你的域名，然后提交, 以后就不会出现这个问题了。 图片链接问题 首先修改_config.yml中post_asset_folder: true 安装插件npm install https://github.com/CodeFalling/hexo-asset-image --save 然后每次新建文章时会多一个和文章名字一样的文件夹，图片可以放在这里 引用图片时可以写![](文件夹/logo.png) 生成html时会自动补充为图片的绝对路径 如何在首页显示文章摘要问题 修改主题的_config.yml文件 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #自动摘要 enable: true length: 150 将值修改为true后首页将展示自动摘要，但是没有格式可言，很丑; 所以这里我们还要手动设置摘要范围 在文章中添加&lt;!-- more --&gt;，表示文章到此为止为摘要部分显示在主页。 阅读次数和评论功能 当NexT主题版本没有升级到V6时，同时开启leancloud_visitors阅读次数和valine评论功能会引起冲突，两种功能时好时坏，解决方法如下： 参照在 NexT 中使用 Valine 评论系统，感谢作者reuixiy！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://sunzhongyuan.net/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://sunzhongyuan.net/tags/Hexo/"}]}]}