<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F09%2F23%2Fregex%2F</url>
    <content type="text"><![CDATA[正则表达式 可以理解为一个模板，用这个模板匹配过滤数据 正则表达式引擎 一套负责解释正则表达式模式并使用这些模板进行文本匹配的底层软件 在linux系统中流行的两种正则表达式引擎 POSIX基础正则表达式（basic regular expression，BRE）引擎 POSIX扩展正则表达式（extended regular expression，ERE）引擎 大多数linux工具都至少符合BRE引擎规范，但是有些工具（比如sed）只符合了BRE的子集，这是出于速度的考虑。 BRE模式 纯文本 特殊字符（. * [] ^ $ {} \ + ? | ()） \：转义字符，用来转义这些特殊字符，另外sed中的/也需要转义echo &quot;3/2&quot;|sed -n &#39;/\//p&#39; ^：行首，用来定义文本行的行首开始的模式，如果放到模式开头之外的其他位置，那么它就是一个普通字符了 $：行尾，用来定义文本行的行尾结束的模式，如果放到模式结尾之外的其他位置，那么它就是一个普通字符了 ^$：空行 .：除换行符之外的任意单个字符 []：字符组，可以作为一个特殊的通配符，与.类似，.通配任意单个字符，[12ab]表示通配1、2、a、b [^]：排除型字符组，[^12ab]表示通配处理1、2、a、b的其他任意字符 [-]：区间型字符组，[0-9]表示通配数字，[a-ce-h]表示通配a到c和e到h的两个区间 [[:alpha:]]：匹配任意字母字符a~z、A~Z [[:alnum:]]：匹配任意字母数字字符0~9、a~z、A~Z [[:blank:]]：匹配空格或制表符 [[:digit:]]：匹配任意数字字符0~9 [[:lower:]]：匹配任意小写字母字符a~z [[:upper:]]：匹配任意大写字母字符A~Z [[:print:]]：匹配任意可打印字符 [[:punct:]]：匹配任意标点符号 [[:space:]]：匹配任意空白字符：空格、制表符、NL、FF、VT、CR * *在正则表达式以为多被定义为通配任意个任意字符，而在正则表达式里则不同，在正则表达式里*要放置在一个字符后面，表明该字符可以出现0次或多次 1echo "abc"|sed -n '/d*/p' #打印abc，因为d可以出现0次 如果限制了位置区间，这个位置区间内不能出现该字符以外其他字符，a[123]*ba和b之间只能出现1、2、3多次或0次，不可以出现字符组以外的字符 12echo "eabcf" | sed -n '/ea*f/p' # 不打印，e和f之间只能出现a多次或0次，这里出现了其他字符b和c，所以不打印echo "eabcf" | sed -n '/e[abcd]*f/p' # 打印eacbdf *前放置的字符有下面几种情况： 没有字符或部分特殊字符如果*前面没有字符或者前边是部分特殊字符，那么它就是一个普通字符了 12echo "ab*c"|sed -n '/*/p' # 打印ab*c，*是一个普通字符echo "*abc"|sed -n '/^*/p' # 打印*abc，*是一个普通字符 普通字符表示该字符必须出现0次或多次 123echo "abc"|sed -n '/d*/p' # 打印abc，d可以出现0次echo "abdddc"|sed -n '/d*/p' # 打印abdddc，d可以出现多次echo "abdc"|sed -n '/ad*c/p' # 不打印，a和c之间只能出现d0次或多次，不可以出现其他字符 特殊字符.*表示任意字符出现0次或多次 1echo "abdc"|sed -n '/.*/p' # 打印abdc 字符组[][]*表示字符组内的任意字符出现0次或多次 12echo "abdc"|sed -n '/[2e42]*/p' # 打印abdcecho "abcdef"|sed -n '/a[bcd]*f/p' # 不打印 ERE模式 特殊字符（. * [] ^ $ {} \ + ? | ()） ?：类似*，不同的是?前面的字符可以出现0次或1次（?代表一个字符，*可以代表多个字符） []?：字符组中的多个字符只能出现一个，并且这个字符只能出现0次或1次 1234echo "asdf"|awk '/a[sd]?f/&#123;print $0&#125;' # 不打印，s和d只能出现一个echo "assf"|awk '/a[sd]?f/&#123;print $0&#125;' # 不打印，s只能出现一次echo "asf"|awk '/a[sd]?f/&#123;print $0&#125;' # 打印asf，出现1次echo "af"|awk '/a[sd]?f/&#123;print $0&#125;' # 打印af，出现0次 +：类似*，不同的是+前面的字符可以出现1次或多次 []+：字符组中的多个字符可以出现1次或多次123echo "af"|awk '/a[sd]+f/&#123;print $0&#125;' # 不打印，出现0次不可以echo "asf"|awk '/a[sd]+f/&#123;print $0&#125;' # 打印asf，出现1次可以echo "asdf"|awk '/a[sd]+f/&#123;print $0&#125;' # 打印asdf，出现多次可以 {}：用来限制字符出现的次数 12345678echo "asf"|awk '/as&#123;1&#125;f/&#123;print $0&#125;' # 打印asfecho "assf"|awk '/as&#123;1&#125;f/&#123;print $0&#125;' # 不打印echo "assf"|awk '/as&#123;1,2&#125;f/&#123;print $0&#125;' # 打印assf，s可以出现1次到2次 echo "asssf"|awk '/as&#123;1,2&#125;f/&#123;print $0&#125;' # 不打印echo "aqwef"|awk '/a.&#123;1,3&#125;f/&#123;print $0&#125;' # 打印aqwef，任意字符出现1次到3次echo "asf"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 打印asfecho "asdf"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 打印asdfecho "assdf"|awk '/a[sd]&#123;1,2&#125;f/&#123;print $0&#125;' # 不打印 |：或/ab|ac/：仅匹配ab或ac ()：分组/(abc)?/：将abc看做一个字符使用，abc可以出现0次或1次 PS. ?：出现0次或1次 +：出现1次或多次 *：出现0次或多次 邮件正则表达式：^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed流编辑器]]></title>
    <url>%2F2018%2F09%2F16%2Fsed%2F</url>
    <content type="text"><![CDATA[sed流编辑器 与交互式文本编辑器(如vim)不同，交互式文本编辑器用键盘来插入、修改和删除数据；而流编辑器则是通过预先设置的规则来编辑数据流。 sed编辑器将修改后的数据输出到stdout标准输出，不会改变原始数据。 sed命令的格式1sed options script file # sed 选项 '[地址]命令' 文件 eg.删除test.txt中所有#开头的行1sed -e '/^#/d' test.txt # -e可以省略 sed会依次执行下列操作： 将test.txt作为输入，从中读取一行数据到sed内部的一个模式缓冲区，也可以从命令管道读取cat test.txt|sed -e &#39;/^#/d&#39; 根据设置的地址/^#/匹配读取的这一行个，判断当前行是否需要处理 如果需要处理则将这一行执行命令d 将模式缓冲区内的这一行输出到stdout标准输入（屏幕），不会改变原始数据 重复上述步骤再从输入读取一行进行匹配、修改、输出，直到处理完所有行 options: 123-n 禁止sed编辑器输出-e script 将script中指定的命令添加到已有的命令中（缺省值）-f file 将file中指定的命令添加到已有的命令中 script: script一般建议用单引号&#39;括起来 script常由地址（行寻址）和命令组成，地址控制了将命令应用到哪些行，缺省为所有行。 行寻址： 如果想让命令作用在某一行，可以在命令前加上行寻址 行寻址有两种形式： 数字方式的行寻址 123sed '2s/a/111/g' test.txt # 只替换第二行sed '2,4s/a/111/g' test.txt # 替换2，3，4行sed '2,$s/a/111/g' test.txt # 替换2到最后一行 使用文本模式过滤器 12/pattern/command # /模式/命令/pattern/,/pattern/command # /模式1/,/模式2/命令 eg. 1234567# 只替换#开头的行sed '/^#/s/a/111/g' test.txt # 替换所有模式1到模式2区间的行，前后包含，可能有多个区间，# 模式1代表开始，模式2代表结束，# 如果没有代表结束的模式2则一直替换到最后一行sed '/a/,/b/s/a/111/g' test.txt sed支持多个命令组合使用： 单个命令 1sed 's/a/111/g' test.txt 多个命令 1234567sed 's/a/111/g; s/b/222/g' test.txt # 注意格式，分号前不能有空格sed -e 's/a/111/g' -e 's/b/222/g' test.txt # 用两个-e实现多命令sed -f aa.sed test.txt # 将多个命令写在一个文件里，一行一个命令，用-f引用这个文件sed ' # 注意格式，输入第一个单引号后可以回车，一行一个命令&gt; s/a/111/g&gt; s/b/222/g&gt; ' test.txt # 输入另一个单引号，表示命令行输入完毕，在这一行要结束整个sed命令 一个地址执行多个命令： 在多个命令组合的基础上加上行寻址，然后把命令用{}括起来即可 12345address&#123; command1 command2 command3&#125; eg. 123456789101112131415161718192021222324252627282930zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '2&#123;&gt; s/line/abcd/g&gt; s/#/!/g&gt; &#125;' test.txtline 1abcd 2!#line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '/^#/&#123;&gt; s/line/abcd/g&gt; s/#/!/g&gt; &#125;' test.txtline 1line 2#!abcd 3line #4!ine 5line 6 sed常用的命令替换s1s/pattern/replacement/flags # s/模式/代替者/替换标记 模式可以理解为正则表达式，在当前行匹配字符串，将匹配的字符串用代替者替换替换标记有四种： 数字：替换标记缺省值为1，表示替换每一行中的第一处模式匹配的地方，指定几，就替换每行中第几处模式匹配的地方 g：替换每行中所有模式匹配的地方，就是替换所有匹配上的字符串 p：这个标记通常和sed的-n选项结合使用，-n会禁止sed编辑器输出，但p会输出修改过的行，结合两个就是只输出被替换命令修改过的行；如果没有-n选项，被修改过的行会打印两遍 w file：功能与p类似，p是打印，w是写到文件里，如果文件存在则覆盖写入 字符串分隔符/可以用其他字符替代： 一个模式如果是路径，路径中的/需要用\转码eg.将/etc/passwd文件中的/bin/bash替换为/bin/csh 1sed 's/\/bin\/bash/\/bin\/csh/g' /etc/passwd 这样转码就麻烦，不便于书写和阅读，所以sed编辑器允许用其他字符代替字符串分隔符/ 1sed 's!/bin/bash!/bin/csh!g' /etc/passwd 删除行d12345sed 'd' test.txt # 删除所有行sed '2d' test.txt # 删除第二行sed '2,$' test.txt # 删除第二行到最后一行sed '/a/d' test.txt # 删除包含a的行sed '/a/,/b/d' test.txt # 删除包含a的行到包含b的行这个区间的所有行，没有包含b的行则会删除到最后一行，谨慎使用 插入a、i sed的插入只能以行为单位插入 i：指定行前插入 a：指定行后插入 123sed '[address]command\new line1\new line2' eg.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354zyzy@zyzy:~/Templates$ echo "line 1" | sed 'i\&gt; line 2\&gt; line 3'line 2line 3line 1zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '1i\&gt; inserted line a\&gt; inserted line b' test.txtinserted line ainserted line bline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '$a\&gt; inserted line a\&gt; inserted line b&gt; ' test.txtline 1line 2##line 3line #4#ine 5line 6inserted line ainserted line bzyzy@zyzy:~/Templates$ sed 'a\!!!!!!!' test.txtline 1!!!!!!!line 2#!!!!!!!#line 3!!!!!!!line #4!!!!!!!#ine 5!!!!!!!!!!!!!!line 6!!!!!!! 修改c12345678910111213141516171819202122232425262728293031323334353637383940414243444546zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed 'c\aaaa' test.txtaaaaaaaaaaaaaaaaaaaaaaaaaaaazyzy@zyzy:~/Templates$ sed '2c\&gt; aaaaa\&gt; bbbbbbbb' test.txtline 1aaaaabbbbbbbb#line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '2,5c\aaaaaaaaa' test.txtline 1aaaaaaaaaline 6zyzy@zyzy:~/Templates$ sed '/#/c\&gt; aaaaaa\&gt; bbbbbbbbb' test.txtline 1aaaaaabbbbbbbbbaaaaaabbbbbbbbbaaaaaabbbbbbbbbaaaaaabbbbbbbbbline 6 转换ysed中唯一一个处理单个字符的命令 1[address]y/inchars/outchars/ inchars和outchars一对一映射，如果inchars和outchars长度不同，则会报错。eg. 1234567891011121314151617181920212223242526272829303132zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed 'y/ln/89/' test.txt8i9e 18i9e 2##8i9e 38i9e #4#i9e 58i9e 6zyzy@zyzy:~/Templates$ sed '2,3y/ln/89/' test.txtline 18i9e 2##8i9e 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '/line 3/y/ln/89/' test.txtline 1line 2##8i9e 3line #4#ine 5line 6 打印打印行p123456789101112131415161718192021222324zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n '2,4p' test.txtline 2##line 3line #4zyzy@zyzy:~/Templates$ sed -n '/#/&#123;&gt; p&gt; s/#//p&gt; &#125;' test.txtline 2#line 2#line 3line 3line #4line 4#ine 5ine 5 打印行号=123456zyzy@zyzy:~/Templates$ sed -n '/line 3/&#123;&gt; =&gt; p&gt; &#125;' test.txt3#line 3 列出行l打印数据流中的文本和不可打印的ascii字符12345678910111213141516zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n 'l' test.txtline 1$line 2#$#line 3$line #4$#ine 5$\t\t$line 6$ \t：制表符tab$：换行符 写入文件w1[address]w filename 覆盖写入文件filename，文件不存在则创建12345678910111213zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed -n '2,4w test2.txt' test.txtzyzy@zyzy:~/Templates$ cat test2.txtline 2##line 3line #4 读取文件r将文件内容插入到数据流中1[address]r filename 将filename中的内容写入到数据流中123456789101112131415161718192021222324252627282930313233343536zyzy@zyzy:~/Templates$ cat test2.txtline 2##line 3line #4zyzy@zyzy:~/Templates$ cat test.txtline 1line 2##line 3line #4#ine 5line 6zyzy@zyzy:~/Templates$ sed '$r test2.txt' test.txtline 1line 2##line 3line #4#ine 5line 6line 2##line 3line #4zyzy@zyzy:~/Templates$ sed '5&#123;&gt; r test2.txt&gt; d&gt; &#125;' test.txtline 1line 2##line 3line #4line 2##line 3line #4line 6]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sed</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux开启ssh服务]]></title>
    <url>%2F2018%2F09%2F02%2Fsshd%2F</url>
    <content type="text"><![CDATA[首先确认系统是否安装了ssh服务输入service sshd status命令查看1234root@zyzy:/etc/ssh# service sshd status● sshd.service Loaded: not-found (Reason: No such file or directory) Active: inactive (dead) Loaded: not-found (Reason: No such file or directory) 说明未安装ssh服务 Active: inactive (dead)说明ssh服务未启动 安装ssh服务sudo apt-get install openssh-server 其他系统如redhat、centos执行以下命令 sudo yum install openssh-server 安装成功后可用service sshd status查看ssh服务是否启动 启动ssh服务service sshd start 使用ssh服务另一台机器执行ssh user@ip回车输入密码即可 PS. 查看ipifconfig 更新root密码sudo passwd root]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac安装linux虚拟机]]></title>
    <url>%2F2018%2F09%2F01%2Fparallels%2F</url>
    <content type="text"><![CDATA[推荐parallelsMac parallels desktop 13破解下载及安装 感谢！！！]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac安装Homebrew]]></title>
    <url>%2F2018%2F08%2F26%2FHomebrew%2F</url>
    <content type="text"><![CDATA[什么是Homebrew 维基百科这样说：Homebrew是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程。[更多] 说白了Homebrew就是Mac系统下的包管理器，相当于Linux的apt-get。 和Linux的包管理器一样，Homebrew提供了简单的命令实现安装、更新、卸载包，并且还能维护包之间的依赖关系，能够帮助你安装一个包时自动安装它的依赖包。 使用Homebrew能安装什么 官网有这样一句话：使用 Homebrew 安装 Apple 没有预装但 你需要的东西。 也可以使用Homebrew提供的命令，通过关键字进行模糊搜索123456mac:~ zyzy$ brew search atom==&gt; Formulaeatomicparsley datomic libatomic_ops mediatomb sratom==&gt; Casks # 有图形界面的软件homebrew/cask-versions/atom-beta homebrew/cask/atom 安装Homebrew1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 更新Homebrew1brew update 卸载Homebrew1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)" 使用Homebrew12345brew install &lt;packageName&gt; # 安装包brew uninstall &lt;packageName&gt; # 卸载包brew search &lt;packageName&gt; # 查询包brew list # 查询已安装的包brew info &lt;packageName&gt; # 查看包信息 PS. 正恶补sed命令，然而发现Mac和Linux上的sed命令有些差距，为降低学习成本，决定在Mac上安装gnu-sed。 12345678910111213141516171819202122232425262728mac:~ zyzy$ brew install gnu-sed --with-default-namesUpdating Homebrew...==&gt; Auto-updated Homebrew!Updated 1 tap (homebrew/core).No changes to formulae.==&gt; Downloading https://ftp.gnu.org/gnu/sed/sed-4.5.tar.xz######################################################################## 100.0%==&gt; ./configure --prefix=/usr/local/Cellar/gnu-sed/4.5==&gt; make install🍺 /usr/local/Cellar/gnu-sed/4.5: 10 files, 528.5KB, built in 1 minute 56 secondsmac:~ zyzy$ cd /usr/local/Cellar/gnu-sed/4.5mac:4.5 zyzy$ ltotal 352-rw-r--r-- 1 zyzy admin 318 8 28 2016 AUTHORS-rw-r--r-- 1 zyzy admin 731 1 17 2017 README-rw-r--r-- 1 zyzy admin 35151 3 7 21:59 COPYING-rw-r--r-- 1 zyzy admin 24088 4 1 09:39 NEWS-rw-r--r-- 1 zyzy admin 103611 4 1 09:40 ChangeLogdrwxr-xr-x 4 zyzy admin 128 8 26 20:59 sharedrwxr-xr-x 3 zyzy admin 96 8 26 20:59 bin-rw-r--r-- 1 zyzy admin 595 8 26 20:59 INSTALL_RECEIPT.jsonmac:4.5 zyzy$ cd binmac:bin zyzy$ ltotal 320-r-xr-xr-x 1 zyzy admin 161660 8 26 20:59 sedmac:bin zyzy$ pwd/usr/local/Cellar/gnu-sed/4.5/bin 将/usr/local/Cellar/gnu-sed/4.5/bin加到PATH即可 --with-default-names会阻止homebrew添加一个”g”到新安装的命令前。这样我们就能使用这些命令的通用名字，从而覆盖掉OS X预装的命令。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Homebrew</tag>
        <tag>macOS</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python必备-virtualenv和virtualenvwrapper总结]]></title>
    <url>%2F2018%2F08%2F18%2FVirtualenv%2F</url>
    <content type="text"><![CDATA[Virtualenv python项目与Java项目不同，Java的每一个项目都会将需要的库重新引用到自己的项目文件夹中； 而在同一开发环境中，python的所有项目都共用一个开发库，将多个项目的包混在一起，这样不利于管理，还会造成包冲突； 所以我们需要用到Virtualenv，它用于创建独立的python开发环境； 可以保证每一个项目都有独立的开发环境，包括不同的python版本。 virtualenvwrapper 它是基于virtualenv之上的管理工具，用来统一管理这些独立的开发环境（虚拟环境）。 快速上手0.安装Virtualenv1pip install virtualenv 1.安装virtualenvwrapper注意请先切换到用户目录，并退出虚拟环境后安装，否则会安装到虚拟环境；1pip install virtualenvwrapper Windows执行这个，Windows版官方文档1pip install virtualenvwrapper-win 2.初始化virtualenvwrapper1source /usr/local/bin/virtualenvwrapper.sh 初始化执行一次即可。 还可以将该命令添加到~/.bashrc或~/.profie或~/.bash_profile等shell启动文件中，以便登陆shell后可直接使用virtualenvwrapper提供的命令。 3.自定义WORKON_HOME virtualenvwrapper默认将所有的虚拟环境放在~/.virtualenvs目录下管理。 可以修改环境变量WORKON_HOME来指定虚拟环境的保存目录。 将以下命令添加到~/.bashrc或~/.profie或~/.bash_profile等shell启动文件中 12export WORKON_HOME=$HOME/envssource /usr/local/bin/virtualenvwrapper.sh 然后source一下让环境变量生效 1source ~/.bash_profile 4.创建虚拟环境1234mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] ENVNAME 直接执行mkvirtualenv可查看命令选项 mkvirtualenv是virtualenvwrapper创建虚拟环境的命令 virtualenv是Virtualenv创建虚拟环境的命令 mkvirtualenv继承了virtualenv命令的所有选项 virtualenv命令选项说明文档https://virtualenv.pypa.io/en/stable/reference/#virtualenv-command 123456789101112mac:~ zyzy$ mkvirtualenv -p python3 --no-site-packages testenv3.6Running virtualenv with interpreter /usr/local/bin/python3Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'New python executable in /Users/zyzy/workspaces/testenv3.6/bin/python3Also creating executable in /Users/zyzy/workspaces/testenv3.6/bin/pythonInstalling setuptools, pip, wheel...done.virtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/predeactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/postdeactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/preactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/postactivatevirtualenvwrapper.user_scripts creating /Users/zyzy/workspaces/testenv3.6/bin/get_env_details(testenv3.6) mac:~ zyzy$ 注意命令行多了(testenv3.6)前缀，说明虚拟环境创建成功，并且已经切换到了虚拟环境 在这个环境里可以用pip安装这个项目需要的包了，不会影响到其他项目 5.退出虚拟环境1deactivate 6.查看有哪些虚拟环境1workon 7.进入虚拟环境1workon testenv3.6 8.删除虚拟环境1rmvirtualenv testenv3.6 也可以直接删除testenv3.6目录 9.其他命令 showvirtualenv [env] 显示指定环境的详情。 cpvirtualenv [source] [dest] 复制一份虚拟环境。 add2virtualenv [dir] [dir] 把指定的目录加入当前使用的环境的path中，这常使用于在多个project里面同时使用一个较大的库的情况。 PS.生成requirements.txt python项目必须包含一个requirements.txt文件，用于记录所有依赖包及其精确的版本号，以便新环境部署。 生成requirements.txt很简单， 首先切换到虚拟环境， 用pip list可以查看当前虚拟环境安装的包，但是这里有三个默认包我们不需要记录； 所以我们用pip freeze命令查看，这个命令不显示默认包，直接将这个命令的输出结果重定向到requirements.txt文件即可 12pip freeze &gt; requirements.txt # 生成requirements.txtpip install -r requirements.txt # 从requirements.txt安装依赖 如何部署没有requirements.txt的项目 可以安装第三方工具pipreqs生成requirements.txt； 这个工具通过扫描源码生成依赖包，所以要切换到项目目录执行， 可能有些不全，需要自己手动调整。 12pip install pipreqs # 安装pipreqspipreqs ./ # 生成requirements.txt]]></content>
      <categories>
        <category>python</category>
        <category>Virtualenv</category>
      </categories>
      <tags>
        <tag>Virtualenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客 GitHub Pages + Hexo]]></title>
    <url>%2F2018%2F08%2F12%2Fhexo%2F</url>
    <content type="text"><![CDATA[0.用hexo在本地创建个人博客创建方法参照：hexo中文官方文档 1.在GitHub上创建一个项目GitHub Pages文档，可以了解一下，这里只用了第一步，创建一个项目。 2.将本地博客上传到GitHub上 将本地git与GitHub绑定（通过SSH） 安装插件npm install hexo-deployer-git --save 编辑Hexo的_config.yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:sunzhongyuan/sunzhongyuan.github.io.git branch: master 执行hexo d -g将生成html文件上传到GitHub 地址栏输入sunzhongyuan.github.io即可访问个人博客 3.绑定个人域名 设置项目sunzhongyuan.github.io 设置个人域名DNS解析 PS.每次执行hexo d -g上传代码后都要重新设置个人域名问题 在hexo目录下的source文件中加入一个文件名为CNAME, 里面写你的域名，然后提交, 以后就不会出现这个问题了。 图片链接问题 首先修改_config.yml中post_asset_folder: true 安装插件npm install https://github.com/CodeFalling/hexo-asset-image --save 然后每次新建文章时会多一个和文章名字一样的文件夹，图片可以放在这里 引用图片时可以写![](文件夹/logo.png) 生成html时会自动补充为图片的绝对路径 如何在首页显示文章摘要问题 修改主题的_config.yml文件 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: #自动摘要 enable: true length: 150 将值修改为true后首页将展示自动摘要，但是没有格式可言，很丑; 所以这里我们还要手动设置摘要范围 在文章中添加&lt;!-- more --&gt;，表示文章到此为止为摘要部分显示在主页。 阅读次数和评论功能 当NexT主题版本没有升级到V6时，同时开启leancloud_visitors阅读次数和valine评论功能会引起冲突，两种功能时好时坏，解决方法如下： 参照在 NexT 中使用 Valine 评论系统，感谢作者reuixiy！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
